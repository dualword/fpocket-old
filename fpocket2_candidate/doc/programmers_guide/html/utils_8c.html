<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>fpocket: utils.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<img src="fpocket_logo_small.png" width="545" height="150">
<!-- Generated by Doxygen 1.5.9 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>utils.c File Reference</h1><code>#include &quot;<a class="el" href="utils_8h_source.html">../headers/utils.h</a>&quot;</code><br>

<p>
<a href="utils_8c_source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="utils_8c.html#4543c2bec43b95a9292a90b98dea4bb5">start_rand_generator</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="utils_8c.html#5492196e16ed2d16bae1df8483ef79ed">rand_uniform</a> (float min, float max)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structtab__str.html">tab_str</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="utils_8c.html#3dc587bc98ec3bb4e3f4bd684aff84c6">f_readl</a> (const char *fpath, int nchar_max)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="utils_8c.html#45e96ff2830a0766313ae00bb068abfc">free_tab_str</a> (<a class="el" href="structtab__str.html">tab_str</a> *tstr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="utils_8c.html#674712dea54e3dcd4c95eb15ff31150d">print_tab_str</a> (<a class="el" href="structtab__str.html">tab_str</a> *strings)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="utils_8c.html#bb731c23a19ad89ea0a69951672a1952">str_is_number</a> (const char *str, const int sign)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="utils_8c.html#b2155f59a3e9691956e8501985f5f362">str_is_float</a> (const char *str, const int sign)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="utils_8c.html#c02faf0c5e3cf0b256a1ad1d37d9b8a2">in_tab</a> (int *tab, int size, int val)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="utils_8c.html#9abd45d3bc4001a047e9ea2866f306b4">index_of</a> (int *tab, int size, int val)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="utils_8c.html#ed930c5e93a75d90a96195282790d467">str_trim</a> (char *str)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="utils_8c.html#abf07eae560605f2838827add7913c56">extract_path</a> (char *str, char *dest)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="utils_8c.html#8a339fa303fb0323a562ba25e2427252">extract_ext</a> (char *str, char *dest)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="utils_8c.html#9096591006dbde3b8c0bca29e6943c4d">remove_path</a> (char *str)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="utils_8c.html#1c104f406d4b5f85b6f0bda8db67536f">remove_ext</a> (char *str)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">FILE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="utils_8c.html#8ec5b0b9f097dc4fc2807ca47d242ac9">fopen_pdb_check_case</a> (char *name, const char *mode)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structtab__str.html">tab_str</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="utils_8c.html#e0345cc28222d9e8d197f0be5704e5bb">str_split</a> (const char *str, const int sep)</td></tr>

<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="utils_8c.html#04b49dd25fed16460f36f3a582dce10e">ST_is_rand_init</a> = 0</td></tr>

</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="8a339fa303fb0323a562ba25e2427252"></a><!-- doxytag: member="utils.c::extract_ext" ref="8a339fa303fb0323a562ba25e2427252" args="(char *str, char *dest)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void extract_ext           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>dest</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
## FUNCTION: extract_ext<p>
## SPECIFICATION: Get rid of the extension of a string (.pdb eg.)<p>
## PARAMETRES: @ char *str: String to deal with @ char *dest : OUTPUT The destination string<p>
## RETURN: 
<p>Definition at line <a class="el" href="utils_8c_source.html#l00548">548</a> of file <a class="el" href="utils_8c_source.html">utils.c</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00549"></a>00549 {
<a name="l00550"></a>00550         <span class="keywordtype">char</span> *pstr = str,
<a name="l00551"></a>00551                  *last_dot = NULL ;
<a name="l00552"></a>00552         
<a name="l00553"></a>00553         <span class="keywordflow">while</span>(*pstr) {
<a name="l00554"></a>00554         <span class="comment">/* Advance in the path name while it is possible */</span>
<a name="l00555"></a>00555                 <span class="keywordflow">if</span>(*pstr == <span class="charliteral">'.'</span>) {
<a name="l00556"></a>00556                 <span class="comment">/* If we encounter a '/', save its position */</span>
<a name="l00557"></a>00557                         last_dot = pstr ;
<a name="l00558"></a>00558                 }
<a name="l00559"></a>00559                 pstr ++ ;
<a name="l00560"></a>00560         }
<a name="l00561"></a>00561 
<a name="l00562"></a>00562         <span class="keywordflow">if</span>(last_dot) {
<a name="l00563"></a>00563                 strcpy(dest, last_dot+1) ;
<a name="l00564"></a>00564         }
<a name="l00565"></a>00565         <span class="keywordflow">else</span> {
<a name="l00566"></a>00566         <span class="comment">/* If no '/' has been found, just return a dot as current folder  */</span>
<a name="l00567"></a>00567                 dest[0] = <span class="charliteral">'\0'</span> ;
<a name="l00568"></a>00568         }
<a name="l00569"></a>00569 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="abf07eae560605f2838827add7913c56"></a><!-- doxytag: member="utils.c::extract_path" ref="abf07eae560605f2838827add7913c56" args="(char *str, char *dest)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void extract_path           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>dest</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
## FUNCTION: extract_path<p>
## SPECIFICATION: Extract path from a string<p>
## PARAMETRES: @ char *str : String to deal with @ char *dest : OUTPUT The destination string<p>
## RETURN: 
<p>Definition at line <a class="el" href="utils_8c_source.html#l00505">505</a> of file <a class="el" href="utils_8c_source.html">utils.c</a>.</p>

<p>Referenced by <a class="el" href="fpout_8c_source.html#l00079">write_out_fpocket()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00506"></a>00506 {
<a name="l00507"></a>00507         <span class="keywordtype">char</span> sav ;      
<a name="l00508"></a>00508         <span class="keywordtype">char</span> *pstr = str,
<a name="l00509"></a>00509                  *last_backsl = NULL ;
<a name="l00510"></a>00510         
<a name="l00511"></a>00511         <span class="keywordflow">while</span>(*pstr) {
<a name="l00512"></a>00512         <span class="comment">/* Advance in the path name while it is possible */</span>
<a name="l00513"></a>00513                 <span class="keywordflow">if</span>(*pstr == <span class="charliteral">'/'</span>) {
<a name="l00514"></a>00514                 <span class="comment">/* If we encounter a '/', save its position */</span>
<a name="l00515"></a>00515                         last_backsl = pstr ;
<a name="l00516"></a>00516                 }
<a name="l00517"></a>00517                 pstr ++ ;
<a name="l00518"></a>00518         }
<a name="l00519"></a>00519 
<a name="l00520"></a>00520         <span class="keywordflow">if</span>(last_backsl) {
<a name="l00521"></a>00521         <span class="comment">/* If we have found one '/' at least, copy the path */</span>
<a name="l00522"></a>00522                 sav = *(last_backsl) ;
<a name="l00523"></a>00523                 (*last_backsl) = <span class="charliteral">'\0'</span> ;
<a name="l00524"></a>00524 
<a name="l00525"></a>00525                 strcpy(dest, str) ;
<a name="l00526"></a>00526                 (*last_backsl) = sav ;  
<a name="l00527"></a>00527         }
<a name="l00528"></a>00528         <span class="keywordflow">else</span> {
<a name="l00529"></a>00529         <span class="comment">/* If no '/' has been found, just return a dot as current folder  */</span>
<a name="l00530"></a>00530                 dest[0] = <span class="charliteral">'\0'</span> ;
<a name="l00531"></a>00531         }
<a name="l00532"></a>00532 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="3dc587bc98ec3bb4e3f4bd684aff84c6"></a><!-- doxytag: member="utils.c::f_readl" ref="3dc587bc98ec3bb4e3f4bd684aff84c6" args="(const char *fpath, int nchar_max)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtab__str.html">tab_str</a>* f_readl           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fpath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nchar_max</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
## FUNCTION: tab_str* f_readl(const char fpath[], int nchar_max)<p>
## SPECIFICATION: Read file line and store them in a <a class="el" href="structtab__str.html">tab_str</a> structure. The function skip empty lines.<p>
## PARAMETRES: @ const char *fpath : Full path of the file. @ int nchar_max : A number giving the max number of caractere in each line.<p>
## RETURN: tab_str* : Pointer to the sab_str structure containing lines of the file. 
<p>Definition at line <a class="el" href="utils_8c_source.html#l00156">156</a> of file <a class="el" href="utils_8c_source.html">utils.c</a>.</p>

<p>References <a class="el" href="memhandler_8c_source.html#l00255">my_free()</a>, <a class="el" href="memhandler_8c_source.html#l00121">my_malloc()</a>, <a class="el" href="utils_8h_source.html#l00078">tab_str::nb_str</a>, and <a class="el" href="utils_8h_source.html#l00077">tab_str::t_str</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00157"></a>00157 {
<a name="l00158"></a>00158 <span class="comment">/*  Variable declaration */</span>
<a name="l00159"></a>00159 
<a name="l00160"></a>00160         FILE *f ;
<a name="l00161"></a>00161         <span class="keywordtype">int</span> i, n,
<a name="l00162"></a>00162                 nb_string ;
<a name="l00163"></a>00163         <span class="keywordtype">char</span> *cline,
<a name="l00164"></a>00164                  **f_lines ;
<a name="l00165"></a>00165         <a class="code" href="structtab__str.html">tab_str</a> *lines ;
<a name="l00166"></a>00166 
<a name="l00167"></a>00167 <span class="comment">/*  Variable initialisation */</span>
<a name="l00168"></a>00168 
<a name="l00169"></a>00169         i = nb_string = 0 ;
<a name="l00170"></a>00170         cline = (<span class="keywordtype">char</span> *) <a class="code" href="memhandler_8c.html#52d7260a38c396cb2dd1dd7abcfd61cb">my_malloc</a>(nchar_max*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>)) ;
<a name="l00171"></a>00171 
<a name="l00172"></a>00172 <span class="comment">/*  How many lines is there in the file? */</span>
<a name="l00173"></a>00173 
<a name="l00174"></a>00174         f = fopen(fpath, <span class="stringliteral">"r"</span>) ;
<a name="l00175"></a>00175         <span class="keywordflow">if</span>(f == NULL) {
<a name="l00176"></a>00176                 <a class="code" href="memhandler_8c.html#a49400242a007d208c641f79856ea4c6">my_free</a>(cline) ;
<a name="l00177"></a>00177                 <span class="keywordflow">return</span> NULL ;
<a name="l00178"></a>00178         }
<a name="l00179"></a>00179         
<a name="l00180"></a>00180         <span class="keywordflow">while</span>(fgets(cline, nchar_max, f) != NULL) {
<a name="l00181"></a>00181                 <span class="keywordflow">if</span>(strcmp(<span class="stringliteral">"\n"</span>, cline) != 0) {
<a name="l00182"></a>00182                         nb_string ++ ;
<a name="l00183"></a>00183                 }
<a name="l00184"></a>00184         }
<a name="l00185"></a>00185         fclose(f) ;
<a name="l00186"></a>00186 
<a name="l00187"></a>00187 <span class="comment">/*  Once we have the number of lines, lets allocate memory and get the lines */</span>
<a name="l00188"></a>00188 
<a name="l00189"></a>00189         f = fopen(fpath, <span class="stringliteral">"r"</span>) ;
<a name="l00190"></a>00190         <span class="keywordflow">if</span>(f == NULL) {
<a name="l00191"></a>00191                 <a class="code" href="memhandler_8c.html#a49400242a007d208c641f79856ea4c6">my_free</a>(cline) ;
<a name="l00192"></a>00192                 <span class="keywordflow">return</span> NULL ;
<a name="l00193"></a>00193         }
<a name="l00194"></a>00194 
<a name="l00195"></a>00195         lines = (<a class="code" href="structtab__str.html">tab_str</a> *)<a class="code" href="memhandler_8c.html#52d7260a38c396cb2dd1dd7abcfd61cb">my_malloc</a>(<span class="keyword">sizeof</span>(<a class="code" href="structtab__str.html">tab_str</a>)) ;
<a name="l00196"></a>00196         f_lines = (<span class="keywordtype">char</span> **)<a class="code" href="memhandler_8c.html#52d7260a38c396cb2dd1dd7abcfd61cb">my_malloc</a>(nb_string*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>*)) ;
<a name="l00197"></a>00197         
<a name="l00198"></a>00198 <span class="comment">/*  Getting lines. */</span>
<a name="l00199"></a>00199 
<a name="l00200"></a>00200         <span class="keywordflow">while</span>(fgets(cline, nchar_max, f) != NULL) {
<a name="l00201"></a>00201                 <span class="keywordflow">if</span>(strcmp(<span class="stringliteral">"\n"</span>, cline) != 0) {
<a name="l00202"></a>00202                         n = strlen(cline) ;
<a name="l00203"></a>00203                         <span class="keywordflow">if</span>(cline[n-1] == <span class="charliteral">'\n'</span>) {
<a name="l00204"></a>00204                                 n ;
<a name="l00205"></a>00205                                 cline[n] = <span class="charliteral">'\0'</span> ;
<a name="l00206"></a>00206                         }
<a name="l00207"></a>00207                         
<a name="l00208"></a>00208                         <span class="keywordtype">char</span> *line =(<span class="keywordtype">char</span> *) <a class="code" href="memhandler_8c.html#52d7260a38c396cb2dd1dd7abcfd61cb">my_malloc</a>((n+1)*<span class="keyword">sizeof</span>(char)) ;
<a name="l00209"></a>00209                         memcpy (line, cline, n+1);
<a name="l00210"></a>00210         
<a name="l00211"></a>00211                         f_lines[i] = line ;
<a name="l00212"></a>00212                         i++ ;
<a name="l00213"></a>00213                 }
<a name="l00214"></a>00214         }
<a name="l00215"></a>00215 
<a name="l00216"></a>00216         lines-&gt;<a class="code" href="structtab__str.html#f2a3e45d6bbc0fc8d45ad2009956f519">nb_str</a>  = nb_string ;
<a name="l00217"></a>00217         lines-&gt;<a class="code" href="structtab__str.html#f7451ee8b95f66bdd78caefbfe55c8fb">t_str</a> = f_lines ;
<a name="l00218"></a>00218 
<a name="l00219"></a>00219 <span class="comment">/*  Free memory and close file */</span>
<a name="l00220"></a>00220 
<a name="l00221"></a>00221         fclose(f) ;
<a name="l00222"></a>00222         <a class="code" href="memhandler_8c.html#a49400242a007d208c641f79856ea4c6">my_free</a>(cline);
<a name="l00223"></a>00223  
<a name="l00224"></a>00224         <span class="keywordflow">return</span> lines ;
<a name="l00225"></a>00225 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="8ec5b0b9f097dc4fc2807ca47d242ac9"></a><!-- doxytag: member="utils.c::fopen_pdb_check_case" ref="8ec5b0b9f097dc4fc2807ca47d242ac9" args="(char *name, const char *mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FILE* fopen_pdb_check_case           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
## FUNCTION: fopen_pdb_check_case<p>
## SPECIFICATION: Try to open a pdb file. If the open failed, put the 4 letter before extention at the lower case and try again. This function assume that the file name has the format path/file.pdb !<p>
## PARAMETERS: @ char *name : The string to parse @ const char *mode : Opening mode<p>
## RETURN: The file, NULL if the openning fails. 
<p>Definition at line <a class="el" href="utils_8c_source.html#l00661">661</a> of file <a class="el" href="utils_8c_source.html">utils.c</a>.</p>

<p>Referenced by <a class="el" href="dparams_8c_source.html#l00300">add_complexe()</a>, <a class="el" href="tparams_8c_source.html#l00306">add_prot()</a>, and <a class="el" href="rpdb_8c_source.html#l00512">rpdb_open()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00662"></a>00662 {
<a name="l00663"></a>00663         FILE *f = fopen(name, mode) ;
<a name="l00664"></a>00664         <span class="keywordflow">if</span>(!f) {
<a name="l00665"></a>00665                 <span class="keywordtype">int</span> len = strlen(name) ;
<a name="l00666"></a>00666                 name[len-5] = toupper(name[len-5]);
<a name="l00667"></a>00667                 name[len-6] = toupper(name[len-6]);
<a name="l00668"></a>00668                 name[len-7] = toupper(name[len-7]);
<a name="l00669"></a>00669                 name[len-8] = toupper(name[len-8]);
<a name="l00670"></a>00670 
<a name="l00671"></a>00671                 f = fopen(name, mode) ;
<a name="l00672"></a>00672                 <span class="keywordflow">if</span>(!f) {
<a name="l00673"></a>00673                         name[len-5] = tolower(name[len-5]);
<a name="l00674"></a>00674                         name[len-6] = tolower(name[len-6]);
<a name="l00675"></a>00675                         name[len-7] = tolower(name[len-7]);
<a name="l00676"></a>00676                         name[len-8] = tolower(name[len-8]);
<a name="l00677"></a>00677                         f = fopen(name, mode) ;
<a name="l00678"></a>00678                         
<a name="l00679"></a>00679                 }
<a name="l00680"></a>00680         }
<a name="l00681"></a>00681 
<a name="l00682"></a>00682         <span class="keywordflow">return</span> f ;
<a name="l00683"></a>00683         
<a name="l00684"></a>00684 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="45e96ff2830a0766313ae00bb068abfc"></a><!-- doxytag: member="utils.c::free_tab_str" ref="45e96ff2830a0766313ae00bb068abfc" args="(tab_str *tstr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void free_tab_str           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtab__str.html">tab_str</a> *&nbsp;</td>
          <td class="paramname"> <em>tstr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
## FUNCTION: free_tab_str<p>
## SPECIFICATION: Free the given structure<p>
## PARAMETRES: @ tab_str* strings : Pointer to the <a class="el" href="structtab__str.html">tab_str</a> to print<p>
## RETURN: void 
<p>Definition at line <a class="el" href="utils_8c_source.html#l00241">241</a> of file <a class="el" href="utils_8c_source.html">utils.c</a>.</p>

<p>References <a class="el" href="memhandler_8c_source.html#l00255">my_free()</a>, <a class="el" href="utils_8h_source.html#l00078">tab_str::nb_str</a>, and <a class="el" href="utils_8h_source.html#l00077">tab_str::t_str</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00242"></a>00242 {
<a name="l00243"></a>00243         <span class="keywordflow">if</span>(tstr) {
<a name="l00244"></a>00244                 <span class="keywordtype">int</span> i ;
<a name="l00245"></a>00245                 <span class="keywordflow">if</span>(tstr-&gt;<a class="code" href="structtab__str.html#f7451ee8b95f66bdd78caefbfe55c8fb">t_str</a>) {
<a name="l00246"></a>00246                         <span class="keywordflow">for</span>(i = 0 ; i &lt; tstr-&gt;<a class="code" href="structtab__str.html#f2a3e45d6bbc0fc8d45ad2009956f519">nb_str</a> ; i++) {
<a name="l00247"></a>00247                                 <span class="keywordflow">if</span>(tstr-&gt;<a class="code" href="structtab__str.html#f7451ee8b95f66bdd78caefbfe55c8fb">t_str</a>[i]) {
<a name="l00248"></a>00248                                         <a class="code" href="memhandler_8c.html#a49400242a007d208c641f79856ea4c6">my_free</a>(tstr-&gt;<a class="code" href="structtab__str.html#f7451ee8b95f66bdd78caefbfe55c8fb">t_str</a>[i]) ;
<a name="l00249"></a>00249                                         tstr-&gt;<a class="code" href="structtab__str.html#f7451ee8b95f66bdd78caefbfe55c8fb">t_str</a>[i] = NULL ;
<a name="l00250"></a>00250                                 }
<a name="l00251"></a>00251                         }
<a name="l00252"></a>00252                         <a class="code" href="memhandler_8c.html#a49400242a007d208c641f79856ea4c6">my_free</a>(tstr-&gt;<a class="code" href="structtab__str.html#f7451ee8b95f66bdd78caefbfe55c8fb">t_str</a>) ;
<a name="l00253"></a>00253                 }
<a name="l00254"></a>00254 
<a name="l00255"></a>00255                 <a class="code" href="memhandler_8c.html#a49400242a007d208c641f79856ea4c6">my_free</a>(tstr) ;
<a name="l00256"></a>00256         }
<a name="l00257"></a>00257 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="c02faf0c5e3cf0b256a1ad1d37d9b8a2"></a><!-- doxytag: member="utils.c::in_tab" ref="c02faf0c5e3cf0b256a1ad1d37d9b8a2" args="(int *tab, int size, int val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int in_tab           </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
## FUNCTION: in_tab<p>
## SPECIFICATION: Check if val is present in tab.<p>
## PARAMETRES: @ int *tab: Tab @ int size: Size of the tab @ int val: Value to check<p>
## RETURN: int: 1 if val is in tab, 0 if not 
<p>Definition at line <a class="el" href="utils_8c_source.html#l00422">422</a> of file <a class="el" href="utils_8c_source.html">utils.c</a>.</p>

<p>Referenced by <a class="el" href="pocket_8c_source.html#l01193">count_pocket_contacted_atms()</a>, <a class="el" href="pocket_8c_source.html#l01137">get_pocket_contacted_atms()</a>, <a class="el" href="voronoi__lst_8c_source.html#l00225">get_vert_contacted_atms()</a>, and <a class="el" href="descriptors_8c_source.html#l00314">set_atom_based_descriptors()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00423"></a>00423 {
<a name="l00424"></a>00424         <span class="keywordflow">if</span>(tab) {
<a name="l00425"></a>00425                 <span class="keywordtype">int</span> i ;
<a name="l00426"></a>00426                 <span class="keywordflow">for</span>(i = 0 ; i &lt; size ; i++) {
<a name="l00427"></a>00427                         <span class="keywordflow">if</span>(tab[i] == val) <span class="keywordflow">return</span> 1 ;
<a name="l00428"></a>00428                 }
<a name="l00429"></a>00429         }
<a name="l00430"></a>00430         
<a name="l00431"></a>00431         <span class="keywordflow">return</span> 0 ;
<a name="l00432"></a>00432 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="9abd45d3bc4001a047e9ea2866f306b4"></a><!-- doxytag: member="utils.c::index_of" ref="9abd45d3bc4001a047e9ea2866f306b4" args="(int *tab, int size, int val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int index_of           </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
## FUNCTION: index_of<p>
## SPECIFICATION: Check if val is present in tab and return its index if so<p>
## PARAMETRES: @ int *tab: Tab @ int size: Size of the tab @ int val: Value to check<p>
## RETURN: int: index if val is in tab, -1 if not 
<p>Definition at line <a class="el" href="utils_8c_source.html#l00450">450</a> of file <a class="el" href="utils_8c_source.html">utils.c</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00451"></a>00451 {
<a name="l00452"></a>00452         <span class="keywordflow">if</span>(tab) {
<a name="l00453"></a>00453                 <span class="keywordtype">int</span> i;
<a name="l00454"></a>00454                 <span class="keywordflow">for</span>(i = 0 ; i &lt; size ; i++) {
<a name="l00455"></a>00455                         <span class="keywordflow">if</span>(val == tab[i]) <span class="keywordflow">return</span> i ;
<a name="l00456"></a>00456                 }
<a name="l00457"></a>00457         }
<a name="l00458"></a>00458         
<a name="l00459"></a>00459         <span class="keywordflow">return</span> -1 ;
<a name="l00460"></a>00460 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="674712dea54e3dcd4c95eb15ff31150d"></a><!-- doxytag: member="utils.c::print_tab_str" ref="674712dea54e3dcd4c95eb15ff31150d" args="(tab_str *strings)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void print_tab_str           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtab__str.html">tab_str</a> *&nbsp;</td>
          <td class="paramname"> <em>strings</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
## FUNCTION: print_tab_str<p>
## SPECIFICATION: Print strings contained in the given <a class="el" href="structtab__str.html">tab_str</a>.<p>
## PARAMETRES: @ tab_str* strings : Pointer to the <a class="el" href="structtab__str.html">tab_str</a> to print<p>
## RETURN: void 
<p>Definition at line <a class="el" href="utils_8c_source.html#l00273">273</a> of file <a class="el" href="utils_8c_source.html">utils.c</a>.</p>

<p>References <a class="el" href="utils_8h_source.html#l00078">tab_str::nb_str</a>, and <a class="el" href="utils_8h_source.html#l00077">tab_str::t_str</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00274"></a>00274 {
<a name="l00275"></a>00275         <span class="keywordflow">if</span>(strings) {
<a name="l00276"></a>00276                 <span class="keywordtype">int</span> i ;
<a name="l00277"></a>00277                 <span class="keywordtype">char</span> **strs = strings-&gt;<a class="code" href="structtab__str.html#f7451ee8b95f66bdd78caefbfe55c8fb">t_str</a> ;
<a name="l00278"></a>00278                 
<a name="l00279"></a>00279                 printf(<span class="stringliteral">"\n-- String tab: \n"</span>);
<a name="l00280"></a>00280                 <span class="keywordflow">for</span> (i = 0 ; i &lt; strings-&gt;<a class="code" href="structtab__str.html#f2a3e45d6bbc0fc8d45ad2009956f519">nb_str</a> ; i++) {
<a name="l00281"></a>00281                         fprintf(stdout, <span class="stringliteral">"&lt;%s&gt;\n"</span>, strs[i]) ;
<a name="l00282"></a>00282                 }
<a name="l00283"></a>00283                 printf(<span class="stringliteral">"--\n"</span>) ;
<a name="l00284"></a>00284         }
<a name="l00285"></a>00285         <span class="keywordflow">else</span> {
<a name="l00286"></a>00286                 fprintf(stderr, <span class="stringliteral">"! Argument NULL in print_tab_str().\n"</span>);
<a name="l00287"></a>00287         }
<a name="l00288"></a>00288 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="5492196e16ed2d16bae1df8483ef79ed"></a><!-- doxytag: member="utils.c::rand_uniform" ref="5492196e16ed2d16bae1df8483ef79ed" args="(float min, float max)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float rand_uniform           </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>max</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
## FONCTION: rand_uniform<p>
## SPECIFICATION: Generate a random number between 0 and 1 using a uniform distribution.<p>
## PARAMETRES: @ float min : Lower boundary @ float max : Upper boundary<p>
## RETURN: double: A uniform random number between min and max 
<p>Definition at line <a class="el" href="utils_8c_source.html#l00123">123</a> of file <a class="el" href="utils_8c_source.html">utils.c</a>.</p>

<p>References <a class="el" href="utils_8c_source.html#l00062">ST_is_rand_init</a>, and <a class="el" href="utils_8c_source.html#l00081">start_rand_generator()</a>.</p>

<p>Referenced by <a class="el" href="atom_8c_source.html#l00178">get_mol_volume_ptr()</a>, <a class="el" href="voronoi_8c_source.html#l00452">get_verts_volume_ptr()</a>, <a class="el" href="tpocket_8c_source.html#l00924">set_mc_overlap_volume()</a>, and <a class="el" href="pocket_8c_source.html#l00275">set_pocket_mtvolume()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00124"></a>00124 {
<a name="l00125"></a>00125         <span class="keywordflow">if</span>(<a class="code" href="utils_8c.html#04b49dd25fed16460f36f3a582dce10e">ST_is_rand_init</a> == 0){
<a name="l00126"></a>00126                 <a class="code" href="utils_8c.html#4543c2bec43b95a9292a90b98dea4bb5">start_rand_generator</a>() ;
<a name="l00127"></a>00127         }
<a name="l00128"></a>00128 
<a name="l00129"></a>00129         <span class="keywordtype">float</span> rnd = 0.0 ;       
<a name="l00130"></a>00130 
<a name="l00131"></a>00131 <span class="preprocessor">        #ifdef MD_USE_GSL       </span><span class="comment">/* GSL */</span>
<a name="l00132"></a>00132                 rnd = gsl_rng_uniform(ST_r) * (max-min) ;
<a name="l00133"></a>00133 <span class="preprocessor">        #else                           </span><span class="comment">/* /GSL */</span>
<a name="l00134"></a>00134                 rnd = ((float)rand()/(float)RAND_MAX) * (max-min) ;
<a name="l00135"></a>00135 <span class="preprocessor">        #endif</span>
<a name="l00136"></a>00136 <span class="preprocessor"></span>
<a name="l00137"></a>00137         <span class="keywordflow">return</span> min+rnd ;
<a name="l00138"></a>00138 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="1c104f406d4b5f85b6f0bda8db67536f"></a><!-- doxytag: member="utils.c::remove_ext" ref="1c104f406d4b5f85b6f0bda8db67536f" args="(char *str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void remove_ext           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>str</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
## FUNCTION: remove_ext<p>
## SPECIFICATION: Remove the extention of a given string<p>
## PARAMETRES: @ char *str: INOUT String to deal with<p>
## RETURN: The input string is modified 
<p>Definition at line <a class="el" href="utils_8c_source.html#l00625">625</a> of file <a class="el" href="utils_8c_source.html">utils.c</a>.</p>

<p>Referenced by <a class="el" href="dparams_8c_source.html#l00113">get_dpocket_args()</a>, <a class="el" href="fpout_8c_source.html#l00079">write_out_fpocket()</a>, <a class="el" href="write__visu_8c_source.html#l00196">write_pymol()</a>, and <a class="el" href="write__visu_8c_source.html#l00098">write_vmd()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00626"></a>00626 {
<a name="l00627"></a>00627         <span class="keywordtype">char</span> *pstr = str,
<a name="l00628"></a>00628                  *last_dot = NULL ;
<a name="l00629"></a>00629         
<a name="l00630"></a>00630         <span class="keywordflow">while</span>(*pstr) {
<a name="l00631"></a>00631         <span class="comment">/* Advance in the path name while it is possible */</span>
<a name="l00632"></a>00632                 <span class="keywordflow">if</span>(*pstr == <span class="charliteral">'.'</span>) {
<a name="l00633"></a>00633                 <span class="comment">/* If we encounter a '/', save its position */</span>
<a name="l00634"></a>00634                         last_dot = pstr ;
<a name="l00635"></a>00635                 }
<a name="l00636"></a>00636                 pstr ++ ;
<a name="l00637"></a>00637         }
<a name="l00638"></a>00638 
<a name="l00639"></a>00639         <span class="keywordflow">if</span>(last_dot) {
<a name="l00640"></a>00640                 *last_dot = <span class="charliteral">'\0'</span> ;
<a name="l00641"></a>00641         }
<a name="l00642"></a>00642 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="9096591006dbde3b8c0bca29e6943c4d"></a><!-- doxytag: member="utils.c::remove_path" ref="9096591006dbde3b8c0bca29e6943c4d" args="(char *str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void remove_path           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>str</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
## FUNCTION: remove_path<p>
## SPECIFICATION: Remove the path from a string<p>
## PARAMETRES: @ char *str: INOUT String to deal with<p>
## RETURN: The input string is modified 
<p>Definition at line <a class="el" href="utils_8c_source.html#l00585">585</a> of file <a class="el" href="utils_8c_source.html">utils.c</a>.</p>

<p>Referenced by <a class="el" href="tpocket_8c_source.html#l00082">test_fpocket()</a>, <a class="el" href="fpout_8c_source.html#l00079">write_out_fpocket()</a>, <a class="el" href="write__visu_8c_source.html#l00196">write_pymol()</a>, and <a class="el" href="write__visu_8c_source.html#l00098">write_vmd()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00586"></a>00586 {
<a name="l00587"></a>00587         <span class="keywordtype">int</span> i, filelen ;
<a name="l00588"></a>00588         <span class="keywordtype">char</span> *pstr = str,
<a name="l00589"></a>00589                  *last_backsl = NULL ;
<a name="l00590"></a>00590         
<a name="l00591"></a>00591         <span class="keywordflow">while</span>(*pstr) {
<a name="l00592"></a>00592         <span class="comment">/* Advance in the path name while it is possible */</span>
<a name="l00593"></a>00593                 <span class="keywordflow">if</span>(*pstr == <span class="charliteral">'/'</span>) {
<a name="l00594"></a>00594                 <span class="comment">/* If we encounter a '/', save its position */</span>
<a name="l00595"></a>00595                         last_backsl = pstr ;
<a name="l00596"></a>00596                 }
<a name="l00597"></a>00597                 pstr = pstr + 1 ;
<a name="l00598"></a>00598         }
<a name="l00599"></a>00599 
<a name="l00600"></a>00600         <span class="keywordflow">if</span>(last_backsl) {
<a name="l00601"></a>00601         <span class="comment">/* If we have found one '/' at least, copy the path, else dont do anything */</span>
<a name="l00602"></a>00602                 last_backsl = last_backsl + 1 ;
<a name="l00603"></a>00603                 filelen = strlen(last_backsl) ;
<a name="l00604"></a>00604                 <span class="keywordflow">for</span>(i = 0 ; i &lt; filelen ; i++) {
<a name="l00605"></a>00605                         str[i] = *(last_backsl+i) ;
<a name="l00606"></a>00606                 }
<a name="l00607"></a>00607                 str[i] = <span class="charliteral">'\0'</span> ;
<a name="l00608"></a>00608         }
<a name="l00609"></a>00609 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="4543c2bec43b95a9292a90b98dea4bb5"></a><!-- doxytag: member="utils.c::start_rand_generator" ref="4543c2bec43b95a9292a90b98dea4bb5" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void start_rand_generator           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
## FONCTION: start_rand_generator<p>
## SPECIFICATION: Initialize generator. This initialisation depends on the library to use.<p>
## PARAMETRES:<p>
## RETURN: void 
<p>Definition at line <a class="el" href="utils_8c_source.html#l00081">81</a> of file <a class="el" href="utils_8c_source.html">utils.c</a>.</p>

<p>References <a class="el" href="utils_8c_source.html#l00062">ST_is_rand_init</a>.</p>

<p>Referenced by <a class="el" href="utils_8c_source.html#l00123">rand_uniform()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00082"></a>00082 {
<a name="l00083"></a>00083         <span class="keywordflow">if</span>(<a class="code" href="utils_8c.html#04b49dd25fed16460f36f3a582dce10e">ST_is_rand_init</a> == 0) {
<a name="l00084"></a>00084 
<a name="l00085"></a>00085 <span class="preprocessor">        #ifdef MD_USE_GSL       </span><span class="comment">/* use GSL if defined */</span>
<a name="l00086"></a>00086 <span class="comment">/*              fprintf(stdout, "&gt; GSL generator used\n"); */</span>
<a name="l00087"></a>00087                 <span class="keywordflow">if</span>(ST_r != NULL) {
<a name="l00088"></a>00088                         gsl_rng_free(ST_r);
<a name="l00089"></a>00089                 }
<a name="l00090"></a>00090 
<a name="l00091"></a>00091                 gsl_rng_default_seed = time(NULL);
<a name="l00092"></a>00092 
<a name="l00093"></a>00093                 <span class="keyword">const</span> gsl_rng_type *T = M_GEN_MTWISTER ;
<a name="l00094"></a>00094                 ST_r = gsl_rng_alloc(T);
<a name="l00095"></a>00095                 gsl_rng_set (ST_r, gsl_rng_default_seed);
<a name="l00096"></a>00096 
<a name="l00097"></a>00097 <span class="preprocessor">        #else                           </span><span class="comment">/* /GSL */</span>
<a name="l00098"></a>00098 
<a name="l00099"></a>00099 <span class="comment">/*              fprintf(stdout, "&gt; Standard C generator used\n"); */</span>
<a name="l00100"></a>00100                 srand((<span class="keywordtype">int</span>)time(NULL));
<a name="l00101"></a>00101 
<a name="l00102"></a>00102 <span class="preprocessor">        #endif</span>
<a name="l00103"></a>00103 <span class="preprocessor"></span>                <a class="code" href="utils_8c.html#04b49dd25fed16460f36f3a582dce10e">ST_is_rand_init</a> = 1 ;
<a name="l00104"></a>00104         }
<a name="l00105"></a>00105 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="b2155f59a3e9691956e8501985f5f362"></a><!-- doxytag: member="utils.c::str_is_float" ref="b2155f59a3e9691956e8501985f5f362" args="(const char *str, const int sign)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int str_is_float           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>sign</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
## FUNCTION: str_is_float<p>
## SPECIFICATION: Check if the string given in argument is a valid float.<p>
## PARAMETRES: @ char *str : The string to deal with @ const int sign : The first caractere is the sign?<p>
## RETURN: int: 1 if its a valid float, 0 else 
<p>Definition at line <a class="el" href="utils_8c_source.html#l00359">359</a> of file <a class="el" href="utils_8c_source.html">utils.c</a>.</p>

<p>Referenced by <a class="el" href="fparams_8c_source.html#l00349">parse_asph_max_size()</a>, <a class="el" href="fparams_8c_source.html#l00321">parse_asph_min_size()</a>, <a class="el" href="fparams_8c_source.html#l00205">parse_clust_max_dist()</a>, <a class="el" href="dparams_8c_source.html#l00355">parse_dist_crit()</a>, <a class="el" href="tparams_8c_source.html#l00370">parse_lig_neigh_dist()</a>, <a class="el" href="fparams_8c_source.html#l00378">parse_mc_niter()</a>, <a class="el" href="fparams_8c_source.html#l00434">parse_refine_dist()</a>, <a class="el" href="fparams_8c_source.html#l00462">parse_refine_minaap()</a>, and <a class="el" href="fparams_8c_source.html#l00234">parse_sclust_max_dist()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00360"></a>00360 {
<a name="l00361"></a>00361         <span class="keywordtype">int</span> ok = 0 ;
<a name="l00362"></a>00362         <span class="keywordtype">int</span> nb_dot = 0 ;
<a name="l00363"></a>00363 
<a name="l00364"></a>00364         <span class="keywordflow">if</span> (str != NULL) {
<a name="l00365"></a>00365                 <span class="keyword">const</span> <span class="keywordtype">char</span> *p = str ;
<a name="l00366"></a>00366                 <span class="keywordtype">int</span> c = *p ;
<a name="l00367"></a>00367 
<a name="l00368"></a>00368                 <span class="comment">/* Checkthe first caractere if the sign has to be taken into account */</span>
<a name="l00369"></a>00369                 <span class="keywordflow">if</span> (sign) {     
<a name="l00370"></a>00370 
<a name="l00371"></a>00371                         <span class="keywordflow">if</span>(isdigit (c) || ((c == <span class="charliteral">'+'</span> || c == <span class="charliteral">'-'</span>) &amp;&amp; str[1] != 0)) {
<a name="l00372"></a>00372                                 ok = 1 ;
<a name="l00373"></a>00373                         }
<a name="l00374"></a>00374                         p++;
<a name="l00375"></a>00375                 }
<a name="l00376"></a>00376                 <span class="keywordflow">else</span> {
<a name="l00377"></a>00377                         ok = 1 ;
<a name="l00378"></a>00378                 }
<a name="l00379"></a>00379 
<a name="l00380"></a>00380                 <span class="keywordflow">if</span> (ok) {
<a name="l00381"></a>00381                         <span class="keywordflow">while</span> (*p != 0) {
<a name="l00382"></a>00382                                 <span class="keywordflow">if</span> (!isdigit (*p)) {
<a name="l00383"></a>00383                                         <span class="keywordflow">if</span>((*p) == <span class="charliteral">'.'</span>) {
<a name="l00384"></a>00384                                                 nb_dot++ ;
<a name="l00385"></a>00385                                                 <span class="keywordflow">if</span>(nb_dot &gt; 1) {
<a name="l00386"></a>00386                                                         ok = 0;
<a name="l00387"></a>00387                                                         break ;
<a name="l00388"></a>00388                                                 }
<a name="l00389"></a>00389                                         }
<a name="l00390"></a>00390                                         <span class="keywordflow">else</span> {
<a name="l00391"></a>00391                                                 ok = 0;
<a name="l00392"></a>00392                                                 break ;
<a name="l00393"></a>00393                                         }
<a name="l00394"></a>00394                                 }
<a name="l00395"></a>00395                                 p++;
<a name="l00396"></a>00396                         }
<a name="l00397"></a>00397                 }
<a name="l00398"></a>00398         }
<a name="l00399"></a>00399         <span class="keywordflow">else</span> {
<a name="l00400"></a>00400                 fprintf(stderr, <span class="stringliteral">"! Argument NULL in str_is_number().\n"</span>);
<a name="l00401"></a>00401         }
<a name="l00402"></a>00402 
<a name="l00403"></a>00403         <span class="keywordflow">return</span> ok;
<a name="l00404"></a>00404 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="bb731c23a19ad89ea0a69951672a1952"></a><!-- doxytag: member="utils.c::str_is_number" ref="bb731c23a19ad89ea0a69951672a1952" args="(const char *str, const int sign)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int str_is_number           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>sign</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
## FUNCTION: str_is_number<p>
## SPECIFICATION: Check if the string given in argument is a number.<p>
## PARAMETRES: @ char *str : The string to deal with @ const int sign : The first caractere is the sign?<p>
## RETURN: int: 1 if its a valid number, 0 else 
<p>Definition at line <a class="el" href="utils_8c_source.html#l00306">306</a> of file <a class="el" href="utils_8c_source.html">utils.c</a>.</p>

<p>Referenced by <a class="el" href="rpdb_8c_source.html#l00307">is_N()</a>, <a class="el" href="fparams_8c_source.html#l00406">parse_basic_vol_div()</a>, <a class="el" href="fparams_8c_source.html#l00291">parse_min_apol_neigh()</a>, <a class="el" href="fparams_8c_source.html#l00490">parse_min_pock_nb_asph()</a>, and <a class="el" href="fparams_8c_source.html#l00262">parse_sclust_min_nneigh()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00307"></a>00307 {
<a name="l00308"></a>00308         <span class="keywordtype">int</span> ok = 0 ;
<a name="l00309"></a>00309 
<a name="l00310"></a>00310         <span class="keywordflow">if</span> (str != NULL) {
<a name="l00311"></a>00311                 <span class="keyword">const</span> <span class="keywordtype">char</span> *p = str ;
<a name="l00312"></a>00312                 <span class="keywordtype">int</span> c = *p ;
<a name="l00313"></a>00313 
<a name="l00314"></a>00314                 <span class="comment">/* Checkthe first caractere if the sign has to be taken into account */</span>
<a name="l00315"></a>00315                 <span class="keywordflow">if</span> (sign) {
<a name="l00316"></a>00316 
<a name="l00317"></a>00317                         <span class="keywordflow">if</span>(isdigit (c) || ((c == <span class="charliteral">'+'</span> || c == <span class="charliteral">'-'</span>) &amp;&amp; str[1] != 0)) {
<a name="l00318"></a>00318                                 ok = 1 ;
<a name="l00319"></a>00319                         }
<a name="l00320"></a>00320                         p++;
<a name="l00321"></a>00321                 }
<a name="l00322"></a>00322                 <span class="keywordflow">else</span> {
<a name="l00323"></a>00323                         ok = 1 ;
<a name="l00324"></a>00324                 }
<a name="l00325"></a>00325 
<a name="l00326"></a>00326                 <span class="keywordflow">if</span> (ok) {
<a name="l00327"></a>00327                         <span class="keywordflow">while</span> (*p != 0) {
<a name="l00328"></a>00328                                 <span class="keywordflow">if</span> (!isdigit (*p)) {
<a name="l00329"></a>00329                                         ok = 0;
<a name="l00330"></a>00330                                         break ;
<a name="l00331"></a>00331                                 }
<a name="l00332"></a>00332                                 p++;
<a name="l00333"></a>00333                         }
<a name="l00334"></a>00334                 }
<a name="l00335"></a>00335         }
<a name="l00336"></a>00336         <span class="keywordflow">else</span> {
<a name="l00337"></a>00337                 fprintf(stderr, <span class="stringliteral">"! Argument NULL in str_is_number().\n"</span>);
<a name="l00338"></a>00338         }
<a name="l00339"></a>00339 
<a name="l00340"></a>00340         <span class="keywordflow">return</span> ok;
<a name="l00341"></a>00341 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="e0345cc28222d9e8d197f0be5704e5bb"></a><!-- doxytag: member="utils.c::str_split" ref="e0345cc28222d9e8d197f0be5704e5bb" args="(const char *str, const int sep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtab__str.html">tab_str</a>* str_split           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>sep</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
## FONCTION: tab_str* str_split_memopt(const char *str, const char sep)<p>
## SPECIFICATION: Split the string given using a char separator. Every token will be stored in a <a class="el" href="structtab__str.html">tab_str</a> structure which will be returned by the function. Empty tokens (two consecutives separator) will be stored as an empty string containing only the NULL caractere.<p>
We optimise here the memory, and allocate the exact memory for each token.<p>
!! MEMORY OF THE RETURNED ARGUMENT MUST BE FREED BY CALLING <a class="el" href="utils_8c.html#45e96ff2830a0766313ae00bb068abfc">free_tab_str()</a> !!<p>
COULD BE OPTIMISED.<p>
## PARAMETRES: @ const char *str: The string to deal with @ const char sep: The separator<p>
## RETURN: tab_str*: A pointer to a structure <a class="el" href="structtab__str.html">tab_str</a> which will contain all elements of the string. 
<p>Definition at line <a class="el" href="utils_8c_source.html#l00711">711</a> of file <a class="el" href="utils_8c_source.html">utils.c</a>.</p>

<p>References <a class="el" href="memhandler_8c_source.html#l00153">my_calloc()</a>, <a class="el" href="utils_8h_source.html#l00078">tab_str::nb_str</a>, and <a class="el" href="utils_8h_source.html#l00077">tab_str::t_str</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00712"></a>00712 {
<a name="l00713"></a>00713         <a class="code" href="structtab__str.html">tab_str</a> *ts = (<a class="code" href="structtab__str.html">tab_str</a>*) <a class="code" href="memhandler_8c.html#e1a54755aeeb11b927875d686a5248c7">my_calloc</a>(1, <span class="keyword">sizeof</span>(<a class="code" href="structtab__str.html">tab_str</a>)) ;
<a name="l00714"></a>00714 
<a name="l00715"></a>00715         <span class="keyword">const</span> <span class="keywordtype">char</span> *pstr = str ;        <span class="comment">// A temp pointer to str</span>
<a name="l00716"></a>00716         <span class="keywordtype">int</span> n = 1 ;                                     <span class="comment">// At least one token (no separator in the string)</span>
<a name="l00717"></a>00717 
<a name="l00718"></a>00718         <span class="comment">//  Count the number of token</span>
<a name="l00719"></a>00719 
<a name="l00720"></a>00720         <span class="keywordflow">while</span>(*pstr) {
<a name="l00721"></a>00721                 <span class="keywordflow">if</span>(*pstr == sep) {
<a name="l00722"></a>00722                         n++ ;
<a name="l00723"></a>00723                 }
<a name="l00724"></a>00724                 pstr ++ ;
<a name="l00725"></a>00725         }
<a name="l00726"></a>00726 
<a name="l00727"></a>00727         ts-&gt;<a class="code" href="structtab__str.html#f2a3e45d6bbc0fc8d45ad2009956f519">nb_str</a> = n ;
<a name="l00728"></a>00728         ts-&gt;<a class="code" href="structtab__str.html#f7451ee8b95f66bdd78caefbfe55c8fb">t_str</a> = (<span class="keywordtype">char</span>**)<a class="code" href="memhandler_8c.html#e1a54755aeeb11b927875d686a5248c7">my_calloc</a>(n, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>*)) ;
<a name="l00729"></a>00729 
<a name="l00730"></a>00730         <span class="comment">//  If there is more than one token, split the string</span>
<a name="l00731"></a>00731 
<a name="l00732"></a>00732         <span class="keywordflow">if</span>(n &gt; 1) {
<a name="l00733"></a>00733                 <span class="keywordtype">char</span> **ptab_str = ts-&gt;<a class="code" href="structtab__str.html#f7451ee8b95f66bdd78caefbfe55c8fb">t_str</a> ;
<a name="l00734"></a>00734                 <span class="keywordtype">char</span> *s_pctok = NULL ;                  <span class="comment">// A pointer to the current created token</span>
<a name="l00735"></a>00735                 <span class="keyword">const</span> <span class="keywordtype">char</span> *s_beg = str ;               <span class="comment">// A pointer used to copy each token from s_beg to next separator</span>
<a name="l00736"></a>00736 
<a name="l00737"></a>00737                 <span class="keywordtype">size_t</span> tok_i = 0,
<a name="l00738"></a>00738                            size_tok = 1 ;
<a name="l00739"></a>00739 
<a name="l00740"></a>00740                 pstr = str ;
<a name="l00741"></a>00741 
<a name="l00742"></a>00742                 <span class="comment">//  Allocate exact memory and copy each tokens</span>
<a name="l00743"></a>00743 
<a name="l00744"></a>00744                 <span class="keywordflow">while</span>(*pstr) {
<a name="l00745"></a>00745                         <span class="keywordflow">if</span>(*pstr == sep) {
<a name="l00746"></a>00746                                 ptab_str[tok_i] = (<span class="keywordtype">char</span>*)<a class="code" href="memhandler_8c.html#e1a54755aeeb11b927875d686a5248c7">my_calloc</a>(size_tok, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>)) ;
<a name="l00747"></a>00747                                 s_pctok = ptab_str[tok_i] ;
<a name="l00748"></a>00748 
<a name="l00749"></a>00749                                 <span class="keywordflow">while</span>(*s_beg != *pstr) {
<a name="l00750"></a>00750                                         *s_pctok = *s_beg ;
<a name="l00751"></a>00751                                         s_pctok ++ ;
<a name="l00752"></a>00752                                         s_beg ++ ;
<a name="l00753"></a>00753                                 }
<a name="l00754"></a>00754                                 *s_pctok = <span class="charliteral">'\0'</span> ;
<a name="l00755"></a>00755 
<a name="l00756"></a>00756                                 size_tok = 0 ;
<a name="l00757"></a>00757                                 tok_i ++ ;
<a name="l00758"></a>00758                                 s_beg ++ ;              <span class="comment">// Skip the separator for next token</span>
<a name="l00759"></a>00759                         }
<a name="l00760"></a>00760                         size_tok ++ ;
<a name="l00761"></a>00761                         pstr ++ ;
<a name="l00762"></a>00762                 }
<a name="l00763"></a>00763 
<a name="l00764"></a>00764         <span class="comment">//  Copy the last token</span>
<a name="l00765"></a>00765 
<a name="l00766"></a>00766                 ptab_str[tok_i] =  (<span class="keywordtype">char</span>*)<a class="code" href="memhandler_8c.html#e1a54755aeeb11b927875d686a5248c7">my_calloc</a>(size_tok, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>)) ;
<a name="l00767"></a>00767                 s_pctok = ptab_str[tok_i] ;
<a name="l00768"></a>00768                 <span class="keywordflow">while</span>(*s_beg) {
<a name="l00769"></a>00769                         *s_pctok = *s_beg ;
<a name="l00770"></a>00770                         s_pctok ++ ;
<a name="l00771"></a>00771                         s_beg ++ ;
<a name="l00772"></a>00772                 }
<a name="l00773"></a>00773                 *s_pctok = <span class="charliteral">'\0'</span> ;
<a name="l00774"></a>00774         }
<a name="l00775"></a>00775         <span class="keywordflow">else</span> {
<a name="l00776"></a>00776         <span class="comment">//  One token only, just copy the original string</span>
<a name="l00777"></a>00777                 ts-&gt;<a class="code" href="structtab__str.html#f7451ee8b95f66bdd78caefbfe55c8fb">t_str</a>[0] =  (<span class="keywordtype">char</span>*)<a class="code" href="memhandler_8c.html#e1a54755aeeb11b927875d686a5248c7">my_calloc</a>(strlen(str), <span class="keyword">sizeof</span>(char));
<a name="l00778"></a>00778                 strcpy(ts-&gt;<a class="code" href="structtab__str.html#f7451ee8b95f66bdd78caefbfe55c8fb">t_str</a>[0], str);
<a name="l00779"></a>00779         }
<a name="l00780"></a>00780 
<a name="l00781"></a>00781         <span class="keywordflow">return</span> ts ;
<a name="l00782"></a>00782 
<a name="l00783"></a>00783 }</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="ed930c5e93a75d90a96195282790d467"></a><!-- doxytag: member="utils.c::str_trim" ref="ed930c5e93a75d90a96195282790d467" args="(char *str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void str_trim           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>str</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
## FUNCTION: str_trim<p>
## SPECIFICATION: Remove spaces from a given string<p>
## PARAMETRES: @ char *str: String to deal with<p>
## RETURN: 
<p>Definition at line <a class="el" href="utils_8c_source.html#l00475">475</a> of file <a class="el" href="utils_8c_source.html">utils.c</a>.</p>

<p>Referenced by <a class="el" href="rpdb_8c_source.html#l00274">guess_element()</a>, <a class="el" href="pertable_8c_source.html#l00258">is_valid_element()</a>, <a class="el" href="check_8c_source.html#l00412">load_pdb_line()</a>, and <a class="el" href="rpdb_8c_source.html#l00156">rpdb_extract_pdb_atom()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00476"></a>00476 {
<a name="l00477"></a>00477         <span class="keywordtype">int</span> i, len;
<a name="l00478"></a>00478         
<a name="l00479"></a>00479         len = strlen(str);
<a name="l00480"></a>00480         <span class="keywordflow">while</span> (len &gt; 0 &amp;&amp; str[len-1] == <span class="charliteral">' '</span>) {
<a name="l00481"></a>00481                 str[len-1] = <span class="charliteral">'\0'</span>;
<a name="l00482"></a>00482                 len--;
<a name="l00483"></a>00483         }
<a name="l00484"></a>00484         
<a name="l00485"></a>00485         <span class="keywordflow">while</span> (len &gt; 0 &amp;&amp; str[0] == <span class="charliteral">' '</span>) {
<a name="l00486"></a>00486                 <span class="keywordflow">for</span> (i=0; i &lt; len; i++) str[i] = str[i+1];
<a name="l00487"></a>00487                 len--;
<a name="l00488"></a>00488         }
<a name="l00489"></a>00489 }
</pre></div>
<p>

</div>
</div><p>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="04b49dd25fed16460f36f3a582dce10e"></a><!-- doxytag: member="utils.c::ST_is_rand_init" ref="04b49dd25fed16460f36f3a582dce10e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="utils_8c.html#04b49dd25fed16460f36f3a582dce10e">ST_is_rand_init</a> = 0<code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Says wether we have seeded the generator. 
<p>Definition at line <a class="el" href="utils_8c_source.html#l00062">62</a> of file <a class="el" href="utils_8c_source.html">utils.c</a>.</p>

<p>Referenced by <a class="el" href="utils_8c_source.html#l00123">rand_uniform()</a>, and <a class="el" href="utils_8c_source.html#l00081">start_rand_generator()</a>.</p>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sun Jul 5 22:10:41 2009 for fpocket by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.9 </small></address>
</body>
</html>
